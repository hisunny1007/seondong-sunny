N, M = map(int, input().split())
nums = list(map(int, input().split()))

# 두 포인터는 로직이 종료될 때까지 절대 뒤로 이동하지 않으므로 위 알고리즘의 시간복잡도는 O(N)이다.
# => 일정한 방향으로 움직이는 게 포인트임
# 투 포인터 알고리즘은 두 가지 종류가 있음
# 두가지 모두 왼쪽 끝에서 시작 (i 가만히 있고 j 움직일 때 그 사이에 정보 확인
# => 두가지 포인터 사이의 값이 모두 중요할 때 = i, j 범위가 중요할 때 같이 출발하는 게 중요함)

# 양쪽 끝에서 시작 왼-> 오 / 왼 <- 오
# => i랑 j가 실제로 찍고 있는 그 값 두개만 중요할 때 양쪽에서 출발하는 게 좋음 (회문 찾을 때~양쪽 찍고 있는 값이 같을 때)

# 범위 중요해 ? => 같은 값
# 찍은 값만 중요해 ? => 양쪽 끝 값


# 투 포인터 언제 움직이지? 조건 젤 중요!
# 그다음 언제 종료시키지?

# 세팅
# 투 포인터를 각각의 변수에 할당
i = j = 0  # 둘 다 왼쪽 끝에서 시작하니까 0번 인덱스를 가리킴
# 정답변수, 임시값
tmp = ans = 0

# 계속 반복(while) # 횟수 정해져 있지 않아서
while True:
    # tmp < M
    if tmp < M:
        # 오른쪽 포인터 N에 가있으면
        if j == N:  # 인덱스는 n-1인데 n이면 갈 곳이 없음
            # 탐색 종료
            break
        # 오른쪽 포인터가 가리키는 값을 tmp에 더하고
        tmp += nums[j]
        # 오른쪽 포인터 이동
        j += 1

    # tmp > M
    elif tmp > M:
        # 왼쪽 포인터가 가리키는 값을 tmp에서 빼고
        tmp -= nums[i]
        # 왼쪽 포인터를 이동
        i += 1

    # tmp == M
    else:
        # 정답 하나 세어주고
        ans += 1
        # 왼쪽 포인터가 가리키는 값을 tmp에서 빼고
        tmp -= nums[i]  # 오른쪽은 잘못 이동했다가는 인덱스 에러날 수 있음
        # 왼쪽 포인터를 이동
        i += 1

print(ans)