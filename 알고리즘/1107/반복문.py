gems = [3, 3, 1, 2, 3, 2, 2, 3, 3, 1]

# 1. 리스트 안에 1이 존재하는지 여부?
    # 반복문을 이용해서 리스트를 순회하며
for gem in gems:
    # 만약 1 이라는 데이터가 발견되었으면
    if gem == 1:
    # 찾았음을 표시하고 종료
        print("찾았다!")
        break
    

# range 반복문, 인덱스 이용해서 접근
# for idx in range(len(gems)) gems 리스트의 길이 바로 알 수 있음
# 0~9 + 1 // 0부터 시작해서 10개를 뽑을 거야 // 출발점이 0이라면 0 생략 가능 (0,10) = (10)

for idx in range(10):
    if gems[idx] == 1:
        print("찾았다!")
        break
    

# 2. 리스트에서 가장 큰 숫자를 찾는 문제
lst = [56, 23, 43, 87, 12, 457, 86]

# 초기값(가장 큰 숫자 후보)을 세팅
ans = -float("INF")
ans = lst[0]


##변수를 갱신할 때, 최대값 세팅 어떻게 하냐? 초기값으로 상당히 큰 숫자 정하면 갱신 잘 안 됨..
## ans = 아주아주 작은 값 넣어줘
# float 실수 만들어주는 함수 inf 


# 반복문을 이용해서 리스트를 선형 탐색
for num in lst:
    # 만약 방금 뽑은 그 값이 그 후보보다 크다면?
    if num > ans:
    # 숫자를 갱신
      ans = num

print(ans)
# print(max(lst))



# 3. 집계 알고리즘 (재구조화)
gems = [3, 3, 1, 2, 3, 2, 2, 3, 3, 1]
#1이 몇개인지, 2가 몇개인지, 3이 몇개인지?..


# 딕셔너리를 이용한 집계 (key값으로 접근)
# 딕셔너리에 1:0, 2:0, 3:0이라는 키값을 만든다.

grades = {1:0, 2:0, 3:0}
# 중괄호도 되고 dict() 함수도 가능
# 데이터 쌍이 필요할 때, 부가 데이터 필요할 때, 데이터 쌍으로 구조화 하는 게 딕셔너리임

# 반복문을 이용해서 리스트를 선형 탐색
for gem in gems:
    # 방금 뽑은 그 등급에 따라서 벨류값을 갱신한다.
    grades[gem] += 1  
    # grades[gem] = grades[gem] + 1


# 딕셔너리는 인덱스 아님, 순서 없어서
print(grades)

# 리스트를 이용한 집계
# 빈 판 만들기
## 인덱스가0123 앞에 0은 사용안함 왜? 123이니까
grades = [0] *4 
#grades = [0, 0, 0, 0]

# 여기서는 인덱스값으로 접근
for gem in gems:
    grades[gem] += 1

print(grades)
    





