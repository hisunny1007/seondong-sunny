# Stack : 후입선출
# (뒤로 가기)
# 데이터의 삽입과 추출이 모두 같은 곳에서 일어난다

# 재귀함수 : 시스템 스택
# (0번의 2번로직-1번의 2번로직-2번의 2번로직...)

# 데이터셋의 한쪽 끝에서만 삽입과 산출이 일어나는 구조임
# 요걸 오른쪽방향으로 가로로 눕혀
# 오른쪽 끝에서만 쌓이고 튀어나감 => list 하나 만들어 놓고 []
# 데이터 들어올 때는 .append()로만 들어오세요~
# 데이터 나갈 때는 .pop()으로만 나가세요~
# => 스택은 리스트로 구현할 수 있다
# 오른쪽으로 쌓아나가고 오른쪽으로 뺄 거야
# => 후입선출 (가장 늦게 들어온 게 가장 빨리 나감)

# 큐 Queue : 선입선출 (먼저 들어온 녀석이 먼저 빠져나감)
# 데이터의 삽입과 추출이 각자 다른 곳에서 일어남

#  데이터를 쌓을 때 오른쪽에서 순서대로 쌓고
# 데이터를 뺄 때에는 왼쪽으로 하나씩 뽑아줘라
# 줄 서는 상황, 대기열

# 큐도 리스트로 구현 가능
# 집어 넣을 떄는 append()
# 뺄 떄는 .pop(0)
# BUT 팝메서드는 시간복잡도..쫌..

# pop 메서드의 시간 복잡도는
# .pop() 뽑기만 하면 끝남 => O(1)
# .pop(0) 인덱스 조정해야 함 => O(N)

# POP제로는 시간 복잡도가 생각보다 높은 연산이라
# 큐는 리스트로 구현하지 않을 거임!!!!!
# => 데크라는 객체 활용함

stack = []

from collections import deque

# deque는 양방향 연결 리스트
# 양방향에서만 데이터 삽입과 추출이 가능해.
# => 그 시간이 엄청나게 빨라

# 일반적인 리스트는 차곡차곡 쌓여있어서 인덱스가 있고 순서가 부여된 것임
# 데크는 좀 더 유연하다. 

queue = deque([1,2,3]) #데크는 안에 iterable한 객체를 넣어줘야하기 때문에 [] 리스트로 묶어서 넣어줘야함
print(queue)

queue.append(5)
print(queue)

num = queue.popleft()
print(num, queue)

# 큐를 구현할 때는 deque라는 객체 사용
# 삽입은 append()
# 추출은 popleft()
# 사용해라